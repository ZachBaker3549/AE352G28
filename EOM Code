from sympy import *
import numpy as np
        
        
params = {
    'm': 1,             # mass (kg)
    'Jx': round(Jx, 6), # moment of inertia about x-axis (kg·m²)
    'Jy': round(Jy, 6), # moment of inertia about y-axis
    'Jz': round(Jz, 6), # moment of inertia about z-axis
    'k': 1.5,           # thrust coefficient (N / rad²/s²)
    'b': 0.5,           # aerodynamic drag coefficient (Nm / rad/s)
    'l': 0.175,         # arm length (m)
    'g': 9.81,          # acceleration due to gravity (m/s²)
}

# Simplify and assign parameter values
m = nsimplify(params['m'])
Jx = nsimplify(params['Jx'])
Jy = nsimplify(params['Jy'])
Jz = nsimplify(params['Jz'])
l = nsimplify(params['l'])
g = nsimplify(params['g'])
k = nsimplify(params['k'])
b = nsimplify(params['b'])
J = diag(Jx, Jy, Jz)

# Define symbols for position, angles, velocity, and angular velocity
p_x, p_y, p_z = symbols('p_x, p_y, p_z')    # position (meters)
psi, theta, phi = symbols('psi, theta, phi') # yaw, pitch, roll angles (radians)
v_x, v_y, v_z = symbols('v_x, v_y, v_z')     # linear velocity (m/s)
w_x, w_y, w_z = symbols('w_x, w_y, w_z')     # angular velocity (rad/s)

# Define net rotor torques and forces
w1, w2, w3, w4 = symbols('w1, w2, w3, w4')   # rotor speeds (rad/s)
tau_x = l * k * (w4**2 - w2**2)              # x-axis torque (Nm)
tau_y = l * k * (w3**2 - w1**2)              # y-axis torque (Nm)
tau_z = b * (w1**2 - w2**2 + w3**2 - w4**2)   # z-axis torque (Nm)
f_z = k * (w1**2 + w2**2 + w3**2 + w4**2)     # net rotor force (N)

# Define rotation matrices
Rz = Matrix([[cos(psi), -sin(psi), 0], [sin(psi), cos(psi), 0], [0, 0, 1]])
Ry = Matrix([[cos(theta), 0, sin(theta)], [0, 1, 0], [-sin(theta), 0, cos(theta)]])
Rx = Matrix([[1, 0, 0], [0, cos(phi), -sin(phi)], [0, sin(phi), cos(phi)]])
R_body_in_world = Rz @ Ry @ Rx

# Calculate angular velocity to angular rates transformation matrix
ex = Matrix([[1], [0], [0]])
ey = Matrix([[0], [1], [0]])
ez = Matrix([[0], [0], [1]])
M = simplify(Matrix.hstack((Ry @ Rx).T @ ez, Rx.T @ ey, ex).inv(), full=True)

# Calculate applied forces and torques
f_in_body = R_body_in_world.T @ Matrix([[0], [0], [-m * g]]) + Matrix([[0], [0], [f_z]])
tau_in_body = Matrix([[tau_x], [tau_y], [tau_z]])

# Define equations of motion
f = Matrix.vstack(
    R_body_in_world @ Matrix([v_x, v_y, v_z]),
    (1 / m) * (f_in_body - Matrix([w_x, w_y, w_z]).cross(m * Matrix([v_x, v_y, v_z]))),
    M @ Matrix([w_x, w_y, w_z]),
    J.inv() @ (tau_in_body - Matrix([w_x, w_y, w_z]).cross(J @ Matrix([w_x, w_y, w_z]))),
)

# Simplify the equations of motion
f = simplify(f, full=True)

# Display the simplified equations of motion
f
